#include <Arduino.h>

//volatile unsigned char stack1[100];
//volatile unsigned char *systemStackPtr = (unsigned char *)0xAB;
//volatile unsigned char *task1StackPtr = (unsigned char *)0xAB;
//unsigned int  switchTask(volatile unsigned char **csp, volatile unsigned char **nsp);

//void task1(int);
//typedef void (*PTF)(int);

/*
void setup() {

	Serial.begin(115200);
	task1StackPtr = &stack1[99];
	task1StackPtr -= 2;
	*((unsigned int *)task1StackPtr) = 0x5678;	// Task Parameter
	task1StackPtr--;

	*task1StackPtr-- = lowByte((unsigned int)task1);
	//*task1StackPtr-- = yabaLow;

	*task1StackPtr-- = highByte((unsigned int)task1);
	//*task1StackPtr-- = yabaHigh;

	//*task1StackPtr-- = (unsigned char)(((unsigned int)task1 & (unsigned int)0x00ff));
	//*task1StackPtr-- = (unsigned char)((unsigned int)task1 >>8);

	task1StackPtr -= 18;

	//for(unsigned int i = 0;i<18;i++){
		//*task1StackPtr =  (0xff - i);
		//Serial.print("stackFill: "); Serial.print((unsigned int)*(task1StackPtr),HEX); Serial.print("\r\n");
		//task1StackPtr--;
	//}
	Serial.print("SystemStackPtr = ");
	Serial.print((unsigned int)systemStackPtr,HEX);
	Serial.print("\r\n");
	Serial.print("Stack top = ");
	Serial.print((unsigned int)&stack1[99],HEX);
	Serial.print("\r\n");
	Serial.print("Task StackPtr = ");
	Serial.print((unsigned int)task1StackPtr,HEX);
	Serial.print("\r\n");
	Serial.print("Task addr = ");
	Serial.print((unsigned int)task1,HEX);
	Serial.print("\r\n");
	delay(500);
	unsigned int result = switchTask(&systemStackPtr, &task1StackPtr);
	Serial.print("Result = ");
	Serial.print(result);
	Serial.print("\r\nSystemStackPtr now = ");
	Serial.print((unsigned int)systemStackPtr,HEX);
	Serial.print("\r\n");
	Serial.print("\r\nSetup Complete\n");
	delay(500);
}

void loop() {

}
void task1(int taskParam)
{
	unsigned int i = 0;
	while(1){
		Serial.print("Hello from T1\r\nTask parameter is:");
		Serial.print(taskParam,HEX);
		Serial.print(" Iteration No:");
		Serial.print(i++);
		Serial.print("\r\n");
		delay(1500);
	}
}
*/
/*
Register Usage
r0 This can be used as a temporary register. If you assigned a value to this
register and are calling code generated by the compiler, you’ll need to save
r0, since the compiler may use it. Interrupt routines generated with the
compiler save and restore this register.

r1 The compiler assumes that this register contains zero. If you use this register
in your assembly code, be sure to clear it before returning to compiler generated
code (use ”clr r1”). Interrupt routines generated with the compiler
save and restore this register, too.

r2–r17, r28, r29 These registers are used by the compiler for storage. If your assembly
code is called by compiler generated code, you need to save and restore any
of these registers that you use. (r29:r28 is the Y index register and is used
for pointing to the function’s stack frame, if necessary.)

r18–r27, r30, r31 These registers are up for grabs. If you use any of these
registers you need to save its contents if you call any compiler generated code.
Function call conventions

Fixed Argument Lists
Function arguments are allocated left to right. They are assigned
from r25 to r8, respectively. All arguments take up an even number of registers (so
that the compiler can take advantage of the movw instruction on enhanced cores.)
If more parameters are passed than will fit in the registers, the rest are passed on
the stack. This should be avoided since

Return Values
8-bit values are returned in r24. 16-bit values are returned in r25:r24.
32-bit values are returned in r25:r24:r23:r22. 64-bit values are returned in r25:-
r24:r23:r22:r21:r20:r19:r18.

A very special extra role is defined for the register pairs R26:R27(RX), R28:R29(RY) and R30:R31(RZ).
The role is so important that these pairs have extra names in assembler: X, Y and Z.
These pairs are 16-bit pointer registers, able to point to adresses with max. 16-bit
into SRAM locations (X, Y or Z) or into locations in program memory (Z).

*/

unsigned int  swap_s(unsigned char **csp,unsigned char **nsp)
{
	asm volatile(
			"push r2\n"
			"push r3\n"
			"push r4\n"
			"push r5\n"
			"push r6\n"
			"push r7\n"
			"push r8\n"
			"push r9\n"
			"push r10\n"
			"push r11\n"
			"push r12\n"
			"push r13\n"
			"push r14\n"
			"push r15\n"
			"push r16\n"
			"push r17\n"
			"push r28\n"
			"push r29\n"

								// Store off current Stack Pointer
			"mov r28,r24\n"
			"mov r29,r25\n"		// Set up Y Pointer to point to csp, where we will store SP
			"IN r6,__SP_L__\n"	// Get SPL
			"ST Y+,r6\n"		// Store current SPL
			"IN r6,__SP_H__\n"	// Get SPH
			"ST Y,r6\n"			// Store current SPH

								// Load new stack pointer
			"mov r28,r22\n"
			"mov r29,r23\n"		// Set up Y Pointer to point to nsp and set SP to contents

			"ld r6,Y+\n"		// Get nsp Low
			"OUT __SP_L__,r6\n"	// Store into SPL
			"mov r26,r6\n"		// Copy of new SPL into RXL, hold to re establish stack frame
			"ld r6,Y\n"			// Get nsp High
			"OUT __SP_H__,r6\n"	// Store into SPH
			"mov r27,r6\n"		// Copy of SPH into RXH, hold to re establish stack frame

								// get parameter off stack and return in reg
			"mov r28,r26\n"		// copy X to Y	to setup Frame Pointer
			"mov r29,r27\n"		// copy X to Y	to setup Frame Pointer
			//"ldd r24,Y+24\n"	//	Retriev the param and store in return reg
			//"ldd r25,Y+23\n"	//	Retriev the param and store in return reg
			"ldd r24,Y+30\n"	//	Retriev the param and store in return reg
			"ldd r25,Y+29\n"	//	Retriev the param and store in return reg

			"pop r29\n"
			"pop r28\n"
			"pop r17\n"
			"pop r16\n"
			"pop r15\n"
			"pop r14\n"
			"pop r13\n"
			"pop r12\n"
			"pop r11\n"
			"pop r10\n"
			"pop r9\n"
			"pop r8\n"
			"pop r7\n"
			"pop r6\n"
			"pop r5\n"
			"pop r4\n"
			"pop r3\n"
			"pop r2\n"
			);
	return true;
}
