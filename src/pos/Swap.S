/*
Register Usage
r0 This can be used as a temporary register. If you assigned a value to this
register and are calling code generated by the compiler, you’ll need to save
r0, since the compiler may use it. Interrupt routines generated with the
compiler save and restore this register.

r1 The compiler assumes that this register contains zero. If you use this register
in your assembly code, be sure to clear it before returning to compiler generated
code (use ”clr r1”). Interrupt routines generated with the compiler
save and restore this register, too.

r2–r17, r28, r29 These registers are used by the compiler for storage. If your assembly
code is called by compiler generated code, you need to save and restore any
of these registers that you use. (r29:r28 is the Y index register and is used
for pointing to the function’s stack frame, if necessary.)

r18–r27, r30, r31 These registers are up for grabs. If you use any of these
registers you need to save its contents if you call any compiler generated code.
Function call conventions

Fixed Argument Lists
Function arguments are allocated left to right. They are assigned
from r25 to r8, respectively. All arguments take up an even number of registers (so
that the compiler can take advantage of the movw instruction on enhanced cores.)
If more parameters are passed than will fit in the registers, the rest are passed on
the stack. This should be avoided since

Return Values
8-bit values are returned in r24. 16-bit values are returned in r25:r24.
32-bit values are returned in r25:r24:r23:r22. 64-bit values are returned in r25:-
r24:r23:r22:r21:r20:r19:r18.

A very special extra role is defined for the register pairs R26:R27(RX), R28:R29(RY) and R30:R31(RZ).
The role is so important that these pairs have extra names in assembler: X, Y and Z.
These pairs are 16-bit pointer registers, able to point to adresses with max. 16-bit
into SRAM locations (X, Y or Z) or into locations in program memory (Z).

*/

.section .text
.global swap_s

//unsigned int  swap_s(unsigned char **csp,unsigned char **nsp)

#include <avr/io.h>

#define __SPL__ 0x3d
#define __SPH__ 0x3e

swap_s:
			cli				// Stop interrupts while we switch stacks
			push r2
			push r3
			push r4
			push r5
			push r6
			push r7
			push r8
			push r9
			push r10
			push r11
			push r12
			push r13
			push r14
			push r15
			push r16
			push r17
			push r28
			push r29

								// Store off current Stack Pointer
			mov r28,r24
			mov r29,r25		// Set up Y Pointer to point to csp, where we will store SP
			IN r6,__SPL__	// Get SPL
			ST Y+,r6		// Store current SPL
			IN r6,__SPH__	// Get SPH
			ST Y,r6			// Store current SPH

								// Load new stack pointer
			mov r28,r22
			mov r29,r23		// Set up Y Pointer to point to nsp and set SP to contents

			ld r6,Y+		// Get nsp Low
			OUT __SPL__,r6	// Store into SPL
			mov r26,r6		// Copy of new SPL into RXL, hold to re establish stack frame
			ld r6,Y			// Get nsp High
			OUT __SPH__,r6	// Store into SPH
			mov r27,r6		// Copy of SPH into RXH, hold to re establish stack frame

								// get parameter off stack and return in reg
			mov r28,r26		// copy X to Y	to setup Frame Pointer
			mov r29,r27		// copy X to Y	to setup Frame Pointer
			ldd r24,Y+24	//	Retriev the tcb and store in return reg
			ldd r25,Y+23	//	Retriev the tcb and store in return reg
//			ldd r24,Y+30	//	Retriev the tcb and store in return reg incl extra 6 SP offset
//			ldd r25,Y+29	//	Retriev the tcb and store in return reg incl extra 6 SP offset

			pop r29
			pop r28
			pop r17
			pop r16
			pop r15
			pop r14
			pop r13
			pop r12
			pop r11
			pop r10
			pop r9
			pop r8
			pop r7
			pop r6
			pop r5
			pop r4
			pop r3
			pop r2
			sei
			ret
	// ** Return Value popped by asm so do not add 'C' return statement
